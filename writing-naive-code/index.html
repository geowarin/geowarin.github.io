<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Writing naive code | Geowarin</title><meta name=keywords content><meta name=description content="Is writing naive code the best way to write code?"><meta name=author content="Geoffroy Warin"><link rel=canonical href=https://geowarin.com/writing-naive-code/><link crossorigin=anonymous href=/assets/css/stylesheet.9833c27727234979007d10a429f9b9c344f4f4afb85485b21ebd2892f3b4c439.css integrity="sha256-mDPCdycjSXkAfRCkKfm5w0T09K+4VIWyHr0okvO0xDk=" rel="preload stylesheet" as=style><link rel=icon href=https://geowarin.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://geowarin.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://geowarin.com/favicon-32x32.png><link rel=apple-touch-icon href=https://geowarin.com/apple-touch-icon.png><link rel=mask-icon href=https://geowarin.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://geowarin.com/writing-naive-code/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://geowarin.com/writing-naive-code/"><meta property="og:site_name" content="Geowarin"><meta property="og:title" content="Writing naive code"><meta property="og:description" content="Is writing naive code the best way to write code?"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-11-17T12:56:42+01:00"><meta property="article:modified_time" content="2022-11-17T12:56:42+01:00"><meta property="og:image" content="https://geowarin.com/writing-naive-code/images/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://geowarin.com/writing-naive-code/images/cover.png"><meta name=twitter:title content="Writing naive code"><meta name=twitter:description content="Is writing naive code the best way to write code?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://geowarin.com/post/"},{"@type":"ListItem","position":2,"name":"Writing naive code","item":"https://geowarin.com/writing-naive-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Writing naive code","name":"Writing naive code","description":"Is writing naive code the best way to write code?","keywords":[],"articleBody":"I stumbled on this article on reddit:\nNo architecture is better than bad architecture - r/programming\nThe article explains three things:\nNo abstraction is better than the wrong abstraction, which I tend to agree with No design is faster than good design, which is more controversial Write naive code first and then identify patterns to base your architecture of off. The last idea is not novel, but I personally agree with it for multiple reasons:\nNaive code is easier to write: it prevents the writer’s block when you begin working on a new feature Naive code is easier to understand: anyone, you or your teammates, can understand and refactor it when needed The most interesting thing about this article, though, is the broader topic it refers to: is naive code good code?\nReflecting on this topic is at the heart of the profession, but I’ve personally been thinking a lot about this lately.\nHaving to work with a couple of juniors, I have to explain why a particular piece of code is better than another and this is no easy task.\nLike wine tasting, code tasting is something that seems to be acquired mostly through experience.\nOther users of reddit had interesting references as well.\nu/loup-vaillant writes:\nThat reminds me of Ousterhout’s Philosophy of Software Design, and Casey Muratori’s semantic compression.\nThe first link is a talk by John Ousterhout, Professor a Standford.\nHe states that the most important thing in all computer science is “problem decomposition”: how do you chop a complicated problem into pieces that you can build independently?\nHis approach is to teach students the principles of software design, a topic that is unfortunately not taught enough because it requires teachers with a sizeable coding experience in the industry, as opposed to mostly academic research and papers.\nHis book sounds like an interesting read and certainly one I would like to discuss with my teammates.\nI also liked what he said about talent being overrated and that “10x programmers” are hard workers and not just “gifted”.\nOusterhout also makes the distinction between “tactical” and “strategic” programming. He coined a name for programmers who write 80% correct code very fast: “tactical tornadoes”. The kind of developers that managers like because they deliver faster, but that their teammates hate because they have to clean up their mess afterwards.\nThe second link on semantic compression makes the same conclusion that writing good code is a matter of experience and that it’s hard to convey.\nI suspect this has something to do with the fact that good programming seems very straightforward once you know how to do it, unlike, say, a fancy math technique that retains its sexiness and makes you want to spend the time to post about it. So, although I don’t have any data to back this up, I strongly suspect that experienced programmers rarely spend time posting about how they program because they just don’t think it’s anything special.\nThe article also dunks on upfront “OOP design” (UML and co) as a non-productive way of thinking about code, which I enjoyed.\nMost importantly, it takes a real world example of a “semantic compression”, a refactoring where transforming a naive, repeated, pattern leads to better code.\nu/eternaloctober writes:\nI always think of this silly list from “Why bad scientific code beats code following “best practices”” https://yosefk.com/blog/why-bad-scientific-code-beats-code-following-best-practices.html\nThis article explains that the code written by scientists is often more enjoyable to work with than code written by “professional” programmers because it doesn’t try to be too clever for its own good.\nu/shevy-java writes:\nIt’s a bit like the Worse is Better article.\nhttps://dreamsongs.com/WorseIsBetter.html\nIt reminded me a bit of this story:\nhttps://www.folklore.org/StoryView.py?story=Make_a_Mess,_Clean_it_Up!.txt\nI highly recommend people to read it, from the pre 1983 era. IMO this is also an example why “Worse is Better” is, oddly enough, actually better than the perceived “perfection” being better. It has to do with non-linear thinking.\nI really like that Richard Gabriel, the author of “worse is better”, a cheeky argument that worse code leads to better results, still has conflicted thoughts about the very proposition he coined 20 years after the fact.\nIs worse really better? Should you write naive code on purpose? Should you dumb yourself down to write the most basic code every time?\nIt certainly reminded me of “Kernighan’s Law”:\nDebugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.\nLike everything in engineering, writing naive code seems to a balancing act between too dumb and too smart, which would certainly explain why finding the right cursor is so hard.\nNote:\nOusterhout talks about David Parnas’ publication as very influential.\n","wordCount":"794","inLanguage":"en","image":"https://geowarin.com/writing-naive-code/images/cover.png","datePublished":"2022-11-17T12:56:42+01:00","dateModified":"2022-11-17T12:56:42+01:00","author":{"@type":"Person","name":"Geoffroy Warin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://geowarin.com/writing-naive-code/"},"publisher":{"@type":"Organization","name":"Geowarin","logo":{"@type":"ImageObject","url":"https://geowarin.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://geowarin.com/ accesskey=h title="Geowarin (Alt + H)">Geowarin</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://geowarin.com/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://geowarin.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://geowarin.com/mastering-spring-mvc-4/ title=Book><span>Book</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://geowarin.com/>Home</a>&nbsp;»&nbsp;<a href=https://geowarin.com/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Writing naive code</h1><div class=post-meta><span title='2022-11-17 12:56:42 +0100 +0100'>November 17, 2022</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Geoffroy Warin</span></div></header><figure class=entry-cover><img loading=eager srcset='https://geowarin.com/writing-naive-code/images/cover_hu_c823781bfbab5c8d.png 360w,https://geowarin.com/writing-naive-code/images/cover_hu_1e7a3dc46bb9c446.png 480w,https://geowarin.com/writing-naive-code/images/cover_hu_954981d04771186f.png 720w,https://geowarin.com/writing-naive-code/images/cover_hu_26a9bf004715a16b.png 1080w,https://geowarin.com/writing-naive-code/images/cover_hu_e196ab48c7b596ae.png 1500w,https://geowarin.com/writing-naive-code/images/cover.png 2700w' src=https://geowarin.com/writing-naive-code/images/cover.png sizes="(min-width: 768px) 720px, 100vw" width=2700 height=1996 alt></figure><div class=post-content><p>I stumbled on this article on reddit:</p><p><a href=https://libreddit.spike.codes/r/programming/comments/ywwxrd/no_architecture_is_better_than_bad_architecture/>No architecture is better than bad architecture - r/programming</a></p><p>The article explains three things:</p><ul><li>No abstraction is better than the wrong abstraction, which I tend to agree with</li><li>No design is faster than good design, which is more controversial</li><li>Write naive code first and then identify patterns to base your architecture of off.</li></ul><p>The last idea is not novel, but I personally agree with it for multiple reasons:</p><ul><li>Naive code is easier to write: it prevents the writer&rsquo;s block when you begin working on a new feature</li><li>Naive code is easier to understand: anyone, you or your teammates, can understand and refactor it when needed</li></ul><p>The most interesting thing about this article, though, is the broader topic it refers to: is naive code good code?</p><p>Reflecting on this topic is at the heart of the profession, but I&rsquo;ve personally been thinking a lot about this lately.</p><p>Having to work with a couple of juniors, I have to explain why a particular piece of code is better than another
and this is no easy task.</p><p>Like wine tasting, code tasting is something that seems to be acquired mostly through experience.</p><hr><p>Other users of reddit had interesting references as well.</p><p><a href=https://libreddit.spike.codes/user/loup-vaillant>u/loup-vaillant</a> writes:</p><blockquote><p>That reminds me of Ousterhout&rsquo;s <a href="https://www.youtube.com/watch?v=bmSAYlu0NcY">Philosophy of Software Design</a>, and Casey Muratori&rsquo;s <a href=https://caseymuratori.com/blog_0015>semantic compression</a>.</p></blockquote><p>The first link is <a href="https://www.youtube.com/watch?v=bmSAYlu0NcY">a talk by John Ousterhout</a>, Professor a Standford.</p><p>He states that the most important thing in all computer science is &ldquo;problem decomposition&rdquo;:
how do you chop a complicated problem into pieces that you can build independently?</p><p>His approach is to teach students the principles of software design, a topic that is unfortunately not taught enough because
it requires teachers with a sizeable coding experience in the industry, as opposed to mostly academic research and papers.</p><p><a href=https://www.goodreads.com/en/book/show/39996759-a-philosophy-of-software-design>His book</a> sounds like an interesting read
and certainly one I would like to discuss with my teammates.</p><p>I also liked what he said about talent being overrated and that &ldquo;10x programmers&rdquo; are hard workers and not just &ldquo;gifted&rdquo;.</p><p>Ousterhout also makes the distinction between &ldquo;tactical&rdquo; and &ldquo;strategic&rdquo; programming.
He coined a name for programmers who write 80% correct code very fast: &ldquo;tactical tornadoes&rdquo;.
The kind of developers that managers like because they deliver faster, but that their teammates hate
because they have to clean up their mess afterwards.</p><p>The second link on <a href=https://caseymuratori.com/blog_0015>semantic compression</a> makes the same conclusion that writing good
code is a matter of experience and that it&rsquo;s hard to convey.</p><blockquote><p>I suspect this has something to do with the fact that good programming seems very straightforward once you know
how to do it, unlike, say, a fancy math technique that retains its sexiness and makes you want to spend the time to post about it.
So, although I don’t have any data to back this up, I strongly suspect that experienced programmers rarely spend time
posting about how they program because they just don’t think it’s anything special.</p></blockquote><p>The article also dunks on upfront &ldquo;OOP design&rdquo; (UML and co) as a non-productive way of thinking about code, which I enjoyed.</p><p>Most importantly, it takes a real world example of a &ldquo;semantic compression&rdquo;, a refactoring where
transforming a naive, repeated, pattern leads to better code.</p><hr><p><a href=https://libreddit.spike.codes/user/eternaloctober>u/eternaloctober</a> writes:</p><blockquote><p>I always think of this silly list from &ldquo;Why bad scientific code beats code following &ldquo;best practices&rdquo;&rdquo; <a href=https://yosefk.com/blog/why-bad-scientific-code-beats-code-following-best-practices.html>https://yosefk.com/blog/why-bad-scientific-code-beats-code-following-best-practices.html</a></p></blockquote><p>This article explains that the code written by scientists is often more enjoyable to work with than code written
by &ldquo;professional&rdquo; programmers because it doesn&rsquo;t try to be too clever for its own good.</p><hr><p><a href=https://libreddit.spike.codes/user/shevy-java>u/shevy-java</a> writes:</p><blockquote><p>It&rsquo;s a bit like the Worse is Better article.</p><p><a href=https://dreamsongs.com/WorseIsBetter.html>https://dreamsongs.com/WorseIsBetter.html</a></p><p>It reminded me a bit of this story:</p><p><a href="https://www.folklore.org/StoryView.py?story=Make_a_Mess,_Clean_it_Up!.txt">https://www.folklore.org/StoryView.py?story=Make_a_Mess,_Clean_it_Up!.txt</a></p><p>I highly recommend people to read it, from the pre 1983 era. IMO this is also an example why &ldquo;Worse is Better&rdquo; is, oddly enough, actually better than the perceived &ldquo;perfection&rdquo; being better. It has to do with non-linear thinking.</p></blockquote><p>I really like that Richard Gabriel, the author of &ldquo;worse is better&rdquo;, a cheeky argument that worse code leads to better results,
still has conflicted thoughts about the very proposition he coined 20 years after the fact.</p><p>Is worse really better? Should you write naive code on purpose? Should you dumb yourself down to write the most basic
code every time?</p><p>It certainly reminded me of &ldquo;Kernighan&rsquo;s Law&rdquo;:</p><blockquote><p>Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly
as possible, you are, by definition, not smart enough to debug it.</p></blockquote><p>Like everything in engineering, writing naive code seems to a balancing act between too dumb and too smart, which
would certainly explain why finding the right cursor is so hard.</p><hr><p>Note:</p><p>Ousterhout talks about <a href=https://www.researchgate.net/profile/David-Parnas/publication/200085877_On_the_Criteria_To_Be_Used_in_Decomposing_Systems_into_Modules/links/55956a7408ae99aa62c72622/On-the-Criteria-To-Be-Used-in-Decomposing-Systems-into-Modules.pdf>David Parnas&rsquo; publication</a>
as very influential.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://geowarin.com/setup-modern-interiors-characters-in-godot/><span class=title>« Prev</span><br><span>Setup Modern interiors characters in godot</span>
</a><a class=next href=https://geowarin.com/what-is-a-good-unit-test/><span class=title>Next »</span><br><span>What is a good unit test?</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Writing naive code on x" href="https://x.com/intent/tweet/?text=Writing%20naive%20code&amp;url=https%3a%2f%2fgeowarin.com%2fwriting-naive-code%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Writing naive code on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fgeowarin.com%2fwriting-naive-code%2f&amp;title=Writing%20naive%20code&amp;summary=Writing%20naive%20code&amp;source=https%3a%2f%2fgeowarin.com%2fwriting-naive-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Writing naive code on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgeowarin.com%2fwriting-naive-code%2f&title=Writing%20naive%20code"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li></ul></footer><section class=comments><script>const theme=document.documentElement.dataset.theme==="light"?"github-light":"photon-dark";let s=document.createElement("script");s.src="https://utteranc.es/client.js",s.setAttribute("repo","geowarin/geowarin.github.io"),s.setAttribute("issue-term","title"),s.setAttribute("theme",theme),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("section.comments").innerHTML="",document.querySelector("section.comments").appendChild(s)</script></section></article></main><footer class=footer><span>&copy; 2026 <a href=https://geowarin.com/>Geowarin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div id=img-overlay style=display:none><button class=close>X</button><div class=overlay-content><img id=img-content><div id=img-caption></div></div></div><script>const figures=document.querySelectorAll("figure > img"),overlay=document.querySelector("#img-overlay");let currentIndex=0;function showOverlay(e){currentIndex=Math.min(Math.max(e,0),figures.length-1);const t=figures[currentIndex];overlay.style.display="flex",document.querySelector("#img-content").src=t.src;const n=t.parentNode.querySelector("figcaption");document.querySelector("#img-caption").innerHTML=n?n.textContent:""}figures.forEach((e,t)=>{e.style.cursor="pointer",e.addEventListener("click",()=>showOverlay(t))});function closeOverlay(){overlay.style.display="none"}document.addEventListener("keydown",e=>{if(overlay.style.display==="none")return;e.key==="Escape"?closeOverlay():e.key==="ArrowRight"?showOverlay(++currentIndex):e.key==="ArrowLeft"&&showOverlay(--currentIndex)}),overlay.addEventListener("click",e=>{e.target===e.currentTarget&&closeOverlay()}),document.querySelector("#img-overlay .close").addEventListener("click",closeOverlay)</script><script>const footnotes=document.querySelectorAll(".footnote-ref");for(const e of footnotes){const t=new URL(e.href).hash.slice(1);e.title=document.getElementById(t)?.textContent.trim().replaceAll("↩︎","")}</script><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>