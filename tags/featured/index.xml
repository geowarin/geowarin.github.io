<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>featured on Geowarin</title><link>https://geowarin.github.io/tags/featured/</link><description>Recent content in featured on Geowarin</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 20 Jan 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://geowarin.github.io/tags/featured/index.xml" rel="self" type="application/rss+xml"/><item><title>Test your Java application with Groovy</title><link>https://geowarin.github.io/test-your-java-application-with-groovy/</link><pubDate>Wed, 20 Jan 2016 00:00:00 +0000</pubDate><guid>https://geowarin.github.io/test-your-java-application-with-groovy/</guid><description>I think Groovy is a wonderful language. However, I would not advise a complete rewrite of your project in Groovy!
We can however use Groovy to test our Java code.
I&amp;rsquo;m actually a big fan of this approach. I&amp;rsquo;ve been using it to test legacy applications written in Java.
I still couldn&amp;rsquo;t use lambdas or fancy Java 8 features but all of a sudden, my test code was more expressive. I could take advantage closures, power asserts, the Spock DSL and Groovy simple syntax.</description></item><item><title>Integration tests with a Docker JUnit Rule</title><link>https://geowarin.github.io/integration-tests-with-a-docker-junit-rule/</link><pubDate>Wed, 06 Jan 2016 00:00:00 +0000</pubDate><guid>https://geowarin.github.io/integration-tests-with-a-docker-junit-rule/</guid><description>When writing integration tests, you might have to run a third party server or middleware. Your tests should remain fast to run and you should be able to run them from your IDE.
Docker seems a good choice for this task!
I just published a small library that contains a JUnit rule allowing you to start Docker containers before your unit tests.
If that sounds of interest to you, you should give it a try and tell me what you think!</description></item><item><title>Spring Boot and React hot loader</title><link>https://geowarin.github.io/spring-boot-and-react-hot-loader/</link><pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate><guid>https://geowarin.github.io/spring-boot-and-react-hot-loader/</guid><description>When I develop web applications, I love using React. I&amp;rsquo;m also a Spring and groovy addict.
Those two stacks make me more productive. Can we have the best of both worlds?
I will show you step by step how I created this project. Feel free to fiddle with it and give me your feedback.
Goal My perfect stack on the backend is to use Spring boot and groovy. With the latest version of Spring boot, there is a new tool called dev-tools that will automatically reload the embedded server when you recompile your project.</description></item><item><title>Completable futures with Spring async</title><link>https://geowarin.github.io/completable-futures-with-spring-async/</link><pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate><guid>https://geowarin.github.io/completable-futures-with-spring-async/</guid><description>Since version 8, java has a way better abstraction than java.util.Future called CompletableFuture. This new API along with the lambdas enables new ways of reasoning with futures by composing, listening and joining them.
Futures are traditionally created by submitting tasks to an Executor. Spring allows declaring one or multiple executors and will submit any method annotated with @Async as tasks for those executors.
The big problem is that executors still return Futures and not CompletableFutures.</description></item><item><title>The missing fish shell tutorial</title><link>https://geowarin.github.io/the-missing-fish-shell-tutorial/</link><pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate><guid>https://geowarin.github.io/the-missing-fish-shell-tutorial/</guid><description>I must admit it after years of trying to avoid writing script shells: I&amp;rsquo;m not a big fan of bash. Sure you can do amazing things when you become a script guru but for someone who spends his life trying to write readable code, it feels a bit unnatural.
So it was with great pleasure and a bit of excitation that I began playing with the new kid in the shell block: fish.</description></item><item><title>Understanding Spring Boot</title><link>https://geowarin.github.io/understanding-spring-boot/</link><pubDate>Fri, 06 Mar 2015 00:00:00 +0000</pubDate><guid>https://geowarin.github.io/understanding-spring-boot/</guid><description>Spring boot is an opinionated library that allows to create executable Spring applications with a convention over configuration approach.
The magic behind this framework lies in the @EnableAutoConfiguration annotation, which will automatically load all the beans the application requires depending on what Spring Boot finds in the classpath.
The @Enable* annotations The @Enable... annotations are not new, they were first introduced in Spring 3 when the idea of replacing the XML files with java annotated classes is born.</description></item><item><title>Complete example of a Spring MVC 3.2 project</title><link>https://geowarin.github.io/complete-example-of-a-spring-mvc-3.2-project/</link><pubDate>Wed, 23 Jan 2013 00:00:00 +0000</pubDate><guid>https://geowarin.github.io/complete-example-of-a-spring-mvc-3.2-project/</guid><description>You want to get started with Spring MVC 3.2 with a complete XML-less configuration? Have a cool simple project with a lot of the nice-to-have features?
A templating framework (we will use SiteMesh for this example - I think it is one of the simplest, most powerful frameworks out there) Localized and custom text and validation messages with reloadable bundles in development UTF-8 encoding filter for your user inputs Use the twitter boostrap for a responsive, slick design Unit tests of your controllers using spring-test-mvc Be able to run it with embedded tomcat or jetty maven plugins?</description></item></channel></rss>